package AFCProg;

/* gram.java */
/* Generated By:JavaCC: Do not edit this line. gram.java */
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.Set;
import java.io.*;

public class gram implements gramConstants {
  public static HashMap<String, String>  listVar ;
  public static HashMap<Integer, String>  listAct;
  public static int cpt=1;
  public static int blockNum=1000;
  public static HashMap <Integer,AEF> Partaef ;
  public static boolean bl=false;
  static public File out ;
  static public FileOutputStream OutStream ;
  static public BufferedWriter buf ;
  static public StringBuffer GUIBuffer;
  static public ArrayList<String> vectAction;

  static void addVar ( String var , String type )
  {
      listVar.put(var, type);

  }
  //
  static void addAct ( int indice , String action )
  {
       listAct.put(indice, action);

  }
  //
 public static void Rebuild(ArrayList<String> vect,String pt,int db ,int fn ){
        int cpt=0;
        boolean continu = true ;
        vect.add(db,pt);
        while ( continu ) {
        vect.remove(db+1);
        cpt ++ ;
        if (cpt==fn-db+1) continu= false ;

    }
 }
 //
public static int ConnectTables(String block){
  int i ;
       AEF temp1 = new AEF(0);
       AEF temp2 = new AEF(0);
                System.out.println(block);

       AEFCreator op = new AEFCreator();

       String toks[] = block.split("((?<=;)|(?=;)|(?=[+])|(?<=[+])|(?<=~)|(?=~)|(?<=[}])|(?=[}])|(?<=[{])|(?=[{]))") ;
       /** to get the first block **/
       if( Integer.parseInt(toks[1]) < 1000)
               //// basic table --> we need to generate a new one
                 temp1 = temp1.GenerateBasic(Integer.parseInt(toks[1]));
           else
               /// Get the Transation table from the hashmap
             temp1 = Partaef.get(Integer.parseInt(toks[1]));

       /** the left side of block **/
       for( i=3 ;i< toks.length-1 ; i=i+2 )
       {

         if( Integer.parseInt(toks[i]) < 1000)
                 //// basic table --> we need to generate a new one
         { temp2 = temp2.GenerateBasic(Integer.parseInt(toks[i]));

         }

             else
                 /// Get the Transation table from the hashmap

               temp2 = Partaef.get(Integer.parseInt(toks[i]));


         // operations
         System.out.println("the operation "+toks[i-1]);


         switch(toks[i-1]) {
         case "+":  temp1 = op.alternative(temp1, temp2); break ;
         case "~": temp1 = op.choice(temp1, temp2); break ;
         case ";": temp1 = op.sequence(temp1, temp2); break ;
         }

       }
       //test 
       for (int l=0;l<temp1.nbState;l++){

          for (int k=0;k<temp1.nbState;k++){
            System.out.print("  "+temp1.matrice [l][k]+"   ");
          }
          System.out.println();

        }
       /** add the partial transition table **/
         Partaef.put(blockNum, temp1);
         blockNum++ ;


      return blockNum-1 ;
}
public static int actionRestantees()
{
  int n=0;
  for(int jj=0;jj<vectAction.size();jj++)
    if ( !(vectAction.get(jj).equals("{")) && !(vectAction.get(jj).equals("}")) && !(vectAction.get(jj).equals("+"))
    && !(vectAction.get(jj).equals(";")) && !(vectAction.get(jj).equals("~")) )
      n++;
  return n;
}
//
public static void global()
{
  int nbAction=0;
  //////////////initilalisation
    vectAction.add(0,"{");
    vectAction.add(vectAction.size(),"}");
    nbAction=actionRestantees();

boolean bool=false,continue2=true;
int taille=vectAction.size(),i=0,cpt=0,indicedbt=0;
StringBuilder temp=new StringBuilder();
//System.out.println("taille "+taille);
while (nbAction!=1)
{
  while (i<taille)
  {
    if(vectAction.get(i).equals("{"))
    {
      if(! (vectAction.get(i+1).equals("{") ) )
      {
        cpt=i+3;
        indicedbt=i;
        temp.append("{"+vectAction.get(i+1));
        if( vectAction.get(i+2).equals("+") || vectAction.get(i+2).equals(";")  || vectAction.get(i+2).equals("~") )
        {
          temp.append(vectAction.get(i+2));
        }
        else if(vectAction.get(i+2).equals("}"))
        {
          temp.append("}");
          continue2=false;
          Rebuild(vectAction,Integer.toString(ConnectTables(temp.toString())),indicedbt,i+2 );
          taille=vectAction.size();
          bool=true;
        }
        while(continue2)
        {
          if(vectAction.get(cpt).equals("{"))
          {
            continue2=false;
          }
          else
          {
            temp.append(vectAction.get(cpt));cpt++;
            if(vectAction.get(cpt-1).equals("}"))
            {

             Rebuild(vectAction,Integer.toString(ConnectTables(temp.toString())),indicedbt,cpt-1 );nbAction=actionRestantees();
              continue2=false;bool=true;
              taille=vectAction.size();
            }
          }
        }
        continue2=true;
        temp.setLength(0); i=(bool)? i+1 : cpt -1; bool=false;
      }
      //
    }
    i++;
  }
  i=0;
}


}
  public static void AFComposer(File file) throws ParseException {
     listVar = new HashMap<String, String>();
     listAct= new HashMap<Integer, String>();
     Partaef = new HashMap <Integer,AEF>();
     GUIBuffer = new StringBuffer(" ||    Component    ||     Type     ||     Holder     ||     Proprities    || ");
     vectAction=new ArrayList<String>();

       try
      {
        out = new File("Composant_"+file.getName()+".gui");
        OutStream = new FileOutputStream(out);
        buf = new BufferedWriter(new OutputStreamWriter(OutStream));
        gram parser = new gram(new InputStreamReader(new FileInputStream(file)));
         parser.prog();
      }
      catch (IOException e) {
      e.printStackTrace();
    }


        // appel de la fonction globale
         global();
         AEF finalAEF = new AEF (0) ;
         finalAEF =  Partaef.get(blockNum-1);
         SaveFiles save= new SaveFiles() ;
         try
         {
         save.CreateAEFile(finalAEF,"AEFTable_"+file.getName());
         save.CreateActionsFile( listAct,"Actions_"+file.getName());
         }
         catch (Exception e) {
         e.printStackTrace();
       }
  }

  static final public void prog() throws ParseException {
    jj_consume_token(BEGIN);
    jj_consume_token(INTERFACE);
    IHM_declaration();
    jj_consume_token(END);
    jj_consume_token(0);
  }

  static final public void IHM_declaration() throws ParseException {Token temp;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMPONENT:{
      jj_consume_token(COMPONENT);
      temp = jj_consume_token(ID);
GUIBuffer.append("\u005cr +-----------------------------------------------------------------------+\u005cn");
                           GUIBuffer.append(" |    "+temp.toString()+"     \u005ct||  ");
      jj_consume_token(TWOPOINTS);
      temp = jj_consume_token(COMPNAMES);
GUIBuffer.append(temp.toString()+"    \u005ct||  ");
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OPENPAR:{
        jj_consume_token(OPENPAR);
        temp = jj_consume_token(ID);
GUIBuffer.append(temp.toString()+"     \u005ct||  ");
        jj_consume_token(CLOSEPAR);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      jj_consume_token(PROPERTY);
      Prop();
      IHM_declaration();
      break;
      }
    case INIT:{
      Init();
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Prop() throws ParseException {Token t;
  Token v ;
  Token w ;
    label_1:
    while (true) {
      t = jj_consume_token(COMPROP);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        jj_consume_token(COMPROP);
      }
GUIBuffer.append(t.toString()+" \u005ct\u005cn\u005ct\u005ct\u005ct\u005ct\u005ct\u005ct\u005ct\u005ct\u005ct\u005ct");
      jj_consume_token(TWOPOINTS);
      v = jj_consume_token(TYPE);
      jj_consume_token(SEQUENCE);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMPROP:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INV:{
      jj_consume_token(INV);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMPROP:{
          ;
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMPROP);
        jj_consume_token(EQUAL);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TYPE:{
          jj_consume_token(TYPE);
          break;
          }
        case TRUE:{
          jj_consume_token(TRUE);
          break;
          }
        case FALSE:{
          jj_consume_token(FALSE);
          break;
          }
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(EVENT);
    label_4:
    while (true) {
      w = jj_consume_token(COMPACTION);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OPENPAR:{
        jj_consume_token(OPENPAR);
        jj_consume_token(COMPNAMES);
        jj_consume_token(CLOSEPAR);
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      condition();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMPACTION:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
    }
addVar(v.image,t.image);
  }

  static final public void condition() throws ParseException {
    jj_consume_token(OPENACO);
    jj_consume_token(IF);
    jj_consume_token(COMPROP);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUAL:{
      jj_consume_token(EQUAL);
      break;
      }
    case DIFF:{
      jj_consume_token(DIFF);
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ENUM:{
      jj_consume_token(ENUM);
      break;
      }
    case VALUE:{
      jj_consume_token(VALUE);
      break;
      }
    case ALPHANUM:{
      jj_consume_token(ALPHANUM);
      break;
      }
    case TRUE:{
      jj_consume_token(TRUE);
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(THEN);
    label_5:
    while (true) {
      operation();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:
      case SEQUENCE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SEQUENCE:{
          jj_consume_token(SEQUENCE);
          break;
          }
        case AND:{
          jj_consume_token(AND);
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMPNAMES:
      case COMPROP:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
    }
    jj_consume_token(CLOSEACO);
  }

  static final public void operation() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMPROP:{
      jj_consume_token(COMPROP);
      break;
      }
    case COMPNAMES:{
      jj_consume_token(COMPNAMES);
      jj_consume_token(42);
      jj_consume_token(COMPROP);
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(AFFECTATION);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ALPHA:{
      jj_consume_token(ALPHA);
      break;
      }
    case ALPHANUM:{
      jj_consume_token(ALPHANUM);
      break;
      }
    case VALUE:{
      jj_consume_token(VALUE);
      break;
      }
    case TRUE:{
      jj_consume_token(TRUE);
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
      break;
      }
    case ENUM:{
      jj_consume_token(ENUM);
      break;
      }
    case COMPNAMES:
    case COMPROP:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMPROP:{
        jj_consume_token(COMPROP);
        break;
        }
      case COMPNAMES:{
        jj_consume_token(COMPNAMES);
        jj_consume_token(42);
        jj_consume_token(COMPROP);
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALTERNATIVE:{
        jj_consume_token(ALTERNATIVE);
        break;
        }
      case 43:{
        jj_consume_token(43);
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COTE:{
        jj_consume_token(COTE);
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHA:{
        jj_consume_token(ALPHA);
        break;
        }
      case ALPHANUM:{
        jj_consume_token(ALPHANUM);
        break;
        }
      case VALUE:{
        jj_consume_token(VALUE);
        break;
        }
      case ID:{
        jj_consume_token(ID);
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COTE:{
        jj_consume_token(COTE);
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Init() throws ParseException {
    try {
      jj_consume_token(INIT);
buf.write(GUIBuffer.toString());buf.close();
      Init_blocks();
    } catch (IOException e) {
e.printStackTrace();
    }
  }

  static final public void Init_blocks() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      jj_consume_token(ID);
      jj_consume_token(DOUBLETWOPOINTS);
      jj_consume_token(COMPROP);
      jj_consume_token(AFFECTATION);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALPHANUM:{
        jj_consume_token(ALPHANUM);
        break;
        }
      case VALUE:{
        jj_consume_token(VALUE);
        break;
        }
      case TRUE:{
        jj_consume_token(TRUE);
        break;
        }
      case FALSE:{
        jj_consume_token(FALSE);
        break;
        }
      case ENUM:{
        jj_consume_token(ENUM);
        break;
        }
      case ID:{
        jj_consume_token(ID);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(SEQUENCE);
      Init_blocks();
      break;
      }
    case ACT:{
      Action_Declaration();
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Action_Declaration() throws ParseException {
    jj_consume_token(ACT);
    action_elim();
    Add_block();
  }

  static final public void action_elim() throws ParseException {Token act,id;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMPACTION:{
      act = jj_consume_token(COMPACTION);
      jj_consume_token(OPENPAR);
      id = jj_consume_token(ID);
vectAction.add(Integer.toString(cpt));addAct(cpt,act.image+"("+id.image+")");cpt++;
      jj_consume_token(CLOSEPAR);
      Add_block();
      break;
      }
    case OPENACO:{
      jj_consume_token(OPENACO);
vectAction.add("{");
      action_elim();
      jj_consume_token(CLOSEACO);
vectAction.add("}");
      Add_block();
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Add_block() throws ParseException {Token op;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEQUENCE:{
      op = jj_consume_token(SEQUENCE);
vectAction.add(op.image);
      action_elim();
      break;
      }
    case CHOICE:{
      op = jj_consume_token(CHOICE);
vectAction.add(op.image);
      action_elim();
      break;
      }
    case ALTERNATIVE:{
      op = jj_consume_token(ALTERNATIVE);
vectAction.add(op.image);
      action_elim();
      break;
      }
    default:
      jj_la1[24] = jj_gen;

    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public gramTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[25];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x800000,0x90,0x10000000,0x0,0x0,0x18000,0x400,0x800000,0x80000000,0x40400000,0x18000,0x42000,0x42000,0x0,0x0,0x0,0x20000,0x20000000,0x0,0x20000000,0x18000,0x18000,0x40,0x82000000,0xe0000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x2,0x2,0x4,0x0,0x0,0x0,0x0,0x98,0x0,0x0,0x3,0x3,0x3,0x800,0x0,0xf0,0x0,0xbb,0xd8,0x40,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public gram(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public gram(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new gramTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public gram(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new gramTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public gram(gramTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(gramTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[44];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 25; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 44; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
